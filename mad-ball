'Mad Ball'Description:  A simple game, like pong or dx-ball'Written by Chase for Computer Experience Programming Class'seed the random number generatorrandomize'misc datalet true = 1let false = 0let newGameFlag = truelet maxFlags = 4let flagChance = 3  '<-- says brick has 1/3 chances to be a flaglet backgroundR = 0let backgroundG = 0let backgroundB = 0'screen datalet screenWidth = 800let screenHeight = 600'scoreboard datalet score = 0let scoreBoardHeight = 20let scoreBoardWidth = 100let scoreBoardX = 0let scoreBoardY = 0let scoreX = 55let scoreY = 10let scoreLabelX = 0let scoreLabelY = scoreYlet scoreLabel$ = "score:"let scoreTextSize = 12let scoreTextFace = 16let scoreTextFont = 5let scoreBoardR = 65535let scoreBoardG = 0let scoreBoardB = 65535'ball datalet maxBalls = 1let ballRadius = 10let ballDiameter = 2*ballRadiuslet ballStartX = int (rnd*screenWidth)let ballStartY = int (rnd*screenHeight/2)let ballStartXS = int (rnd*5)-2let ballStartYS = 1let maxBallSpeedX = 3let maxBallSpeedY = 3let ballAccelleration = 0.1let ballR = 65535let ballG = 0let ballB = 0dim ballX (maxBalls)dim ballY (maxBalls)dim ballXS (maxBalls)dim ballYS (maxBalls)dim ballSprite (maxBalls)'paddle datalet paddleWidth = 100let paddleHeight = 10let paddleX = (screenWidth/2)-(paddleWidth/2)let paddleY = (screenHeight/2)-(paddleHeight/2)let paddleR = 0let paddleG = 65535let paddleB = 0'brick datalet brickWidth = 40let brickHeight = 15let brickHoverConstant = 0.02let maxBrickValue = 25let brickR = 65535let brickG = 65535let brickB = 65535let doneBricks = 0let maxBricks = 5dim brickX (maxBricks)dim brickY (maxBricks)dim brickXS (maxBricks)dim brickYS (maxBricks)dim showBrick (maxBricks)dim brickValue (maxBricks)dim brickFlag (maxBricks)dim brickSprite (maxBricks)'gravity datalet gravityFlag = falselet gravityPull = 0.02let gravityFlagValue = 1'horizontal gravity datalet horizontalGravityFlag = falselet horizontalGravityPull = 0.01let horizontalGravityFlagValue = 2'force feild datalet forceFeildFlag = falselet forceFeildPush = 0.006let forceFeildFlagValue = 3'LSD datalet LSDFlag = falselet LSDBackcolorR = 65535let LSDBackcolorG = 65535let LSDBackcolorB = 65535let LSDBallcolorR = 65535let LSDBallcolorG = 65535let LSDBallcolorB = 65535let LSDPaddlecolorR = 65535let LSDPaddlecolorG = 65535let LSDPaddlecolorB = 65535let LSDBrickcolorR = 65535let LSDBrickcolorG = 65535let LSDBrickcolorB = 65535let LSDTimerInterval = 0.2let LSDTimer = timer + LSDTimerIntervallet LSDFlagValue = 4'initialize screensballScreen = init screen (0, 0, ballDiameter, ballDiameter)paddleScreen = init screen (0, 0, paddleWidth, paddleHeight)brickScreen = init screen (0, 0, brickWidth, brickHeight)scoreBoardScreen = init screen (0, 0, scoreBoardWidth, scoreBoardHeight)bufferScreen = init screen (0, 0, screenWidth, screenHeight)'set render portset sprite render port to bufferScreenno sprite backgroundset sprite mask color to 0, 0, 0'prepare screen for game'i've used a bit depth of 32 to speed up graphics speed'and since the graphics aren't too special it shouldn't'effect their qualityset screen to bufferScreenfullscreen mode 800, 600, 32hidecursor'begin main game event loopSTARTGAME:do until keymap key ("q") or keymap key ("Q")   'first we MUST check to see if a new game is about to begin   if newGameFlag = true then gosub NEWGAME   'clear old renders from the screen upon each loop   set screen to bufferScreen   cls      'get paddle's positions   getmousexy mouseX, mouseY   paddleX = mouseX-paddleWidth/2   paddleY = screenHeight-paddleHeight      'keep paddle inside the screen   if paddleX < 0 then paddleX = 0   if paddleX+paddleWidth > screenWidth then paddleX = screenWidth-paddleWidth      'ballin baby...   for i = 1 to maxBalls         if ballXS (i) = 0 then ballXS (i) = ballXS (i) + 0.5      if ballYS (i) = 0 then ballYS (i) = ballYS (i) + 0.5         ballX (i) = ballX (i) + ballXS (i)      ballY (i) = ballY (i) + ballYS (i)            'keep balls bouncing off the paddle...      if ballX (i)+ballRadius >= paddleX and ballX (i)+ballRadius <= paddleX+paddleWidth and ballY (i)+ballDiameter >= paddleY then         if ballYS (i) >= 0 then ballYS (i) = -ballYS (i)-ballAccelleration         if ballX (i)+ballRadius < paddleX+int(paddleWidth/3) then            ballXS (i) = ballXS (i)-1         end if         if ballX (i)+ballRadius > paddleX+paddleWidth-int(paddleWidth/3) then            ballXS (i) = ballXS (i)+1         end if      end if      if ballX (i)+ballRadius < paddleX and ballX (i)+ballDiameter > paddleX and ballY (i)+ballDiameter >= paddleY then         if ballXS (i) >= 0 then            ballXS (i) = -ballXS (i)         else            ballXS (i) = ballXS (i) - 0.5         end if      end if      if ballX (i)+ballRadius > paddleX+paddleWidth and ballX (i) < paddleX+paddleWidth and ballY (i)+ballDiameter >= paddleY then         if ballXS (i) >= 0 then            ballXS (i) = ballXS (i) + 0.5         else            ballXS (i) = -ballXS (i)         end if      end if            'keep balls inside the screen...      if ballX (i)+ballDiameter >= screenWidth then         if ballXS (i) >= 0 then ballXS (i) = -ballXS (i)      end if      if ballX (i) <= 0 then         if ballXS (i) < 0 then ballXS (i) = -ballXS (i)      end if      if ballY (i) <= 0 then          if ballYS (i) < 0 then ballYS (i) = -ballYS (i)      end if      if ballY (i) >= screenHeight then         gosub LOSER      end if            'check for gravity flag      if gravityFlag = true then         ballYS (i) = ballYS (i)+gravityPull      end if            'check for horizontal gravity flag      if horizontalGravityFlag = true then         if ballX (i) < screenWidth/2 then ballXS (i) = ballXS (i) - horizontalGravityPull         if ballX (i) > screenWidth/2 then ballXS (i) = ballXS (i) + horizontalGravityPull      end if            'check for force feild flag      if forceFeildFlag = true then         if ballX (i) < screenWidth/2 then ballXS (i) = ballXS (i) + forceFeildPush         if ballX (i) > screenWidth/2 then ballXS (i) = ballXS (i) - forceFeildPush         if ballY (i) < screenHeight/2 then ballYS (i) = ballYS (i) + forceFeildPush      end if            'check for LSD flag      if LSDFlag = true then         if ballSprite (i) <> 0 then kill sprite ballSprite (i)         set screen to ballScreen         LSDBallcolorR = int (rnd*65535)+1         LSDBallcolorG = int (rnd*65535)+1         LSDBallcolorB = int (rnd*65535)+1         forecolor LSDBallcolorR, LSDBallcolorG, LSDBallcolorB         cls         if int (rnd*2) = 0 then            circle ballRadius, ballRadius, ballRadius         else            fcircle ballRadius, ballRadius, ballRadius         end if         ballSprite (i) = grab sprite (0 ,0, ballDiameter, ballDiameter)         set screen to bufferScreen      end if            set sprite ballSprite (i), ballX (i), ballY (i)         next i      'brickin baby   doneBricks = 0   for i=1 to maxBricks            'keep the bricks inside the screen      if brickX (i) + brickWidth > screenWidth then         brickX (i) = screenWidth-brickWidth         if brickXS (i) > 0 then brickXS (i) = -brickXS (i)      end if      if brickX (i) < 0 then         brickX (i) = 0         if brickXS (i) < 0 then brickXS (i) = -brickXS (i)      end if      if brickY (i) > screenHeight/2 then         'brickY (i) = screenHeight/2 - brickHeight         'if brickYS (i) > 0  then brickYS (i) = -brickYS (i)         brickYS (i) = brickYS (i) - brickHoverConstant      end if      if brickY (i) < 0 then         brickY (i) = 0         if brickYS (i) < 0 then brickYS (i) = -brickYS (i)      end if            'check to see if ball are colliding with bricks      for j=1 to maxBalls         if sprite collides (ballSprite (j), brickSprite (i)) = -1 then            'hide the brick            hide sprite brickSprite (i)            showBrick (i) = false            'reset the score            score = score + brickValue (i)            set screen to scoreBoardScreen            forecolor scoreBoardR, scoreBoardG, scoreBoardB            textsize scoreTextSize            textface scoreTextFace            textfont scoreTextFont            cls            text scoreLabelX, scoreLabelY, scoreLabel$            text scoreX, scoreY, str$ (score)            if scoreBoardSprite <> 0 then kill sprite scoreBoardSprite            scoreBoardSprite = grab sprite (0, 0, scoreBoardWidth, scoreBoardHeight)            'activate flag            if brickFlag (i) = gravityFlagValue then gravityFlag = true            if brickFlag (i) = horizontalGravityFlagValue then horizontalGravityFlag = true            if brickFlag (i) = forceFeildFlagValue then forceFeildFlag = true            if brickFlag (i) = LSDFlagValue then LSDFlag = true         end if      next j            'check to see if bricks are colliding with bricks      for j=1 to maxBricks         if i<>j and sprite collides (brickSprite (i), brickSprite (j)) = -1 then            tmpS = brickXS (i)            brickXS (i) = brickXS (j)            brickXS (j) = tmpS            tmpS = brickYS (i)            brickYS (i) = brickYS (j)            brickYS (j) = tmpS         end if      next j            'brick velocity      brickX (i) = brickX (i) + brickXS (i)      brickY (i) = brickY (i) + brickYS (i)            'count all the keeled bricks and total them      'if all the bricks are dead then you win!      if showBrick (i) = false then doneBricks = doneBricks + 1      if doneBricks = maxBricks then gosub WINNER            'only set the brick's sprite if it hasn't been knocked out      if showBrick (i) = true then set sprite brickSprite (i), brickX (i), brickY (i)         next i      'check for LSD flag   if LSDFLAG = true then      if paddleSprite <> 0 then kill sprite paddleSprite      set screen to paddleScreen      LSDPaddlecolorR = int (rnd*65535)+1      LSDPaddlecolorG = int (rnd*65535)+1      LSDPaddlecolorB = int (rnd*65535)+1      forecolor LSDPaddlecolorR, LSDPaddlecolorG, LSDPaddlecolorB      cls      rect 0, 0, paddleWidth, paddleHeight      paddleSprite = grab sprite (0, 0, paddleWidth, paddleHeight)      set screen to bufferScreen      LSDBackcolorR = int (rnd*65535)+1      LSDBackcolorG = int (rnd*65535)+1      LSDBackcolorB = int (rnd*65535)+1      backcolor LSDBackcolorR, LSDBackcolorG, LSDBackcolorB   end if      set sprite paddleSprite, paddleX, paddleY   set sprite scoreBoardSprite, scoreBoardX, scoreBoardY      render sprites      copyrect 0, 0, screenWidth, screenHeight, 0, 0, screenWidth, screenHeight, 0, bufferScreen, console   loop'begin sub routinesRESETBACKGROUND:   set screen to bufferScreen   backgroundR = 0   backgroundG = 0   backgroundB = 0   backcolor backgroundR, backgroundG, backgroundBreturnRESETBALL:   set screen to ballScreen   cls   forecolor ballR, ballG, ballB   fcircle ballRadius, ballRadius, ballRadius   ballStartX = int (rnd*screenWidth)   ballStartY = int (rnd*screenHeight/2)   ballStartXS = int(rnd*5)-2   for i = 1 to maxBalls      ballX (i) = ballStartX      ballY (i) = ballStartY      ballXS (i) = ballStartXS      ballYS (i) = ballStartYS      if ballSprite (i) <> 0 then kill sprite ballSprite (i)      ballSprite (i) = grab sprite (0, 0, ballDiameter, ballDiameter)   next ireturnRESETPADDLE:   set screen to paddleScreen   cls   forecolor paddleR, paddleG, paddleB   poly 0, 0, 0, paddleWidth, paddleWidth, paddleHeight, paddleWidth, 0   paddleX = screenWidth/2   paddleY = screenHeight-paddleHeight   if paddleSprite <> 0 then kill sprite paddleSprite   paddleSprite = grab sprite (0, 0, paddleWidth, paddleHeight)returnRESETSCOREBOARD:   score = 0   set screen to scoreBoardScreen   cls   forecolor scoreBoardR, scoreBoardG, scoreBoardB   textsize scoreTextSize   textface scoreTextFace   textfont scoreTextFont   text scoreLabelX, scoreLabelY, scoreLabel$   text scoreX, scoreY, str$ (score)   if scoreBoardSprite <> 0 then kill sprite scoreBoardSprite   scoreBoardSprite = grab sprite (0, 0, scoreBoardWidth, scoreBoardHeight)returnRESETBRICKS:   let doneBricks = 0   set screen to brickScreen   for i=1 to maxBricks      showBrick (i) = true      brickValue (i) = int (rnd*maxBrickValue)+1      brickFlag (i) = int ((rnd*maxFlags)*flagChance)+1      brickX (i) = int (rnd*screenWidth)+1      brickY (i) = int (rnd*screenHeight/2)      do until brickXS (i) <> 0         brickXS (i) = int (rnd*4)-2      loop      do until brickYS (i) <> 0         brickYS (i) = int (rnd*4)-2      loop      cls      forecolor brickR, brickG, brickB      rect 0, 0, brickWidth, brickHeight      if brickSprite (i) <> 0 then kill sprite brickSprite (i)      brickSprite (i) = grab sprite (0, 0, brickWidth, brickHeight)      set sprite brickSprite (i), brickX (i), brickY (i)      for j=1 to i-1         if i - 1 <> 0 then            if sprite collides (brickSprite (i), brickSprite (j)) = -1 then i = i-1         end if      next j   next ireturnRESETFLAGS:   maxFlags = 4   gravityFlag = false   horizontalGravityFlag = false   forceFeildFlag = false   LSDFlag = falsereturnNEWGAME:   gosub RESETBACKGROUND   gosub RESETBALL   gosub RESETBRICKS   gosub RESETPADDLE   gosub RESETSCOREBOARD   gosub RESETFLAGS   set screen to bufferScreen      textface 16   textfont 11   textsize 20   forecolor int (rnd*65535)+1, int (rnd*65535)+1, int (rnd*65535)+1   text (screenWidth/2)/2, screenHeight/2, "Click the mouse to start a new game."      copyrect 0, 0, screenWidth, screenHeight, 0, 0, screenWidth, screenHeight, 0, bufferScreen, console      do until button = -1         keymap scan      if keymap key ("q") or keymap key ("Q") then gosub QUITGAME      loop      newGameFlag = false   gosub STARTGAMEreturnWINNER:   set screen to bufferScreen   cls   textface 32   textfont 24   textsize 30   forecolor int (rnd*65535)+1, int (rnd*65535)+1, int (rnd*65535)+1   text (screenWidth/3)*2, screenHeight/3, "YOU WIN!"   gosub NEWGAMEreturnLOSER:   set screen to bufferScreen   cls   textface 32   textfont 24   textsize 30   forecolor int (rnd*65535)+1, int (rnd*65535)+1, int (rnd*65535)+1   text screenWidth/3, screenHeight/3, "YOU LOSE!"   gosub NEWGAMEreturnQUITGAME:   kill screen ballScreen   kill screen paddleScreen   kill screen brickScreen   kill screen scoreBoardScreen   kill screen bufferScreen   showcursor   end